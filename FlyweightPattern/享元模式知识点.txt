1.内存溢出，司空见惯
	内存溢出两种可能：
		内存泄漏：
			无意识的代码缺陷，导致内存泄漏，JVM不能获得连续的内存空间
		对象太多
			代码写的太烂，产生的对象太多，内存被耗尽。
	自己设计一个共享池，需要实现如下两个功能：索引值。
		容器的定义
			我们要定义一个池容器，在这个容器中容纳哪些对象
		提供客户端访问的接口
			我们要提供一个接口供客户端访问，池中有可用的对象，可以直接从池中获得，否则建立一个新的对象，并放入池中
		把对象相同属性提取出来，不同的属性在系统内进行赋值处理
2.享元模式的定义
	是池技术的最重要的实现
	使用共享对象可有效地支持大量的细粒度的对象
	要求细粒度对象，那么不可避免地使对象数量多且性质相似，将这些对象的信息分为两个部分：
		内部状态：
			是对象可共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变
			如例子的id，postAddress等
			它们可以作为一个对象的动态附加信息，不必直接存储在具体某个对象中，属于可以共享的部分
		外部状态：
			就是对象得以依赖的一个标记。
			是随环境改变而改变
			不可以共享的额状态
			如我们来自中的考试科目+考试地点复合字符串，它是一批对象的统一标识，是唯一的索引值
	Flyweight--抽象享元角色
		一个产品的抽象类
		同时定义出对象的外部状态和内部状态的接口或者实现
	ConcreteFlywight--具体的享元角色
		具体的一个产品类，实现抽象角色定义的业务，，
		该角色中需要住的的是内部状态处理应该与环境无关
		不应该出现一个操作改变了内部状态，同时修改了外部状态
	unsharedConcreteFlyweight---不可共享的享元角色
		不存在外部状态或者安全要求如线程安全，不能够使用共享计数的对象
		该对象一般不会出现在享元工厂中
	FlyweightFactory--享元工厂
		职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。
	享元模式的目的在于运用享元技术，使得一些细粒度的对象可以共享
	多使用细粒度的对象，
3.享元模式的应用
	3.1.享元模式的优点和缺点
		可以大大减少应用程序创建的对象
		降低程序内存的占哟个
		增强程序的性能
		不过同时也提高了系统的复杂性
		需要分离出外部状态和内部状态
		而且外部状态具有固化特性，不应该随内部状态改变而改变，导致系统逻辑的混乱。
	3.2.享元模式的使用场景
		系统存在大量相似对象
		细粒度的对象都具备接近的外部状态，而且内部状态与环境无关，对象没有特定身份
		需要缓冲池的场景
4.享元模式的扩展
	4.1.线程安全问题
		在使用享元模式，对象池中的享元对象尽量多，多到满足业务为止。
	4.2.性能平衡
		外部状态最好以java的基本类型作为标识